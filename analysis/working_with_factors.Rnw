\documentclass[fleqn,10pt,lineno]{wlpeerj}

\usepackage{url}

\let\proglang=\textsf
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}
\def\newblock{\hskip .11em plus .33em minus .07em}


\title{Wrangling categorical data in R}

\author[1]{Amelia McNamara}
\affil[1]{Smith College}


\keywords{}

\begin{abstract}
Wrangling of categorical data is an important part of the analysis cycle.  Many aspects of these operations can be tricky, particularly for complex transformations.  This paper discusses aspects of transformation of categorical 
variables in R. We suggest defensive coding strategies and principles for data wrangling 
to ensure data quality and sound analysis.
\end{abstract}

\begin{document}

<<setup, include=FALSE>>=
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, size='footnotesize')
@

\flushbottom
\maketitle
\thispagestyle{empty}

\section*{Introduction}

The wrangling of 
categorical data is an important component in data science because so many variables are categorical. While defensive coding is always important for any analysis, categorical data presents some particular problems that can slip in without the analyst noticing. 

In this paper, we consider a number of common idioms that often arise in data cleaning and preparation, propose some guidelines for defensive coding, and discuss some settings where analysts often get tripped up when working with categorical variables and factor (R's data type for categorical data). 

\section*{History of factors in R}
Consider a gender variable including the categories \verb#male#, \verb#female# and \verb#gender non-conforming#. In R, there are two ways to store this information. One is to use a series of character strings, and the other is to store it as a factor.  

Historically, storing categorical data as a factor variable was more efficient than storing the same data as strings, because factor variables only store the factor labels once~\citep{Pen2015}. However, R has changed to use hashed versions of all character strings, so the storage issue is no longer a consideration~\citep{Pen2015}. 

XX Ordered factors vs. unordered?


Factors can be very tricky to deal with, since many operations applied to them return different values than when applied to character vectors.  As an example, consider an indicator of smoking status.

<<>>=
smokestatus <- c("Current", "Current", "Former", "Never")
str(smokestatus[1])
smokestatus == "Current"
smokefactor <- factor(smokestatus)
str(smokefactor[1])
smokefactor == "Current"
@

XX Amelia, this doesn't misbehave in the way that I had imagined.  Neither does:

<<>>=
levels <- c(10, 10, 20, 20, 50, 50)
levelgrp <- factor(levels, ordered=TRUE)
levelgrp[3] < levelgrp[5]
levelgrp==10
@

XX can you find an example when it does mess you up?

This behavior has led to the online \verb#stringsAsFactors=HELLNO# movement. This refers to the default behavior of many of R's data import functions to take any variable composed as strings and automatically convert the variable to a factor. Man in the R community have been moving away from this default behavior, with functions from Hadley Wickham's \pkg{readr} package defaulting to leaving strings as-is. (Others have chosen to add \verb#options(stringAsFactors=FALSE)# into their 
startup commands.)

However, factor variables are important when it comes to modeling. When you pass a factor variable into \pkg{lm} or \pkg{glm}, \proglang{R} automatically creates dummy variables for each of the levels and picks one as a reference group. This behavior is lost if the variable is stored as a character vector.  

So, factors are important. But, they can often be hard to deal with. Because of the way the group numbers are stored separately from the factor labels, it can be easy to overwrite data in such a way that the original data is lost. In this paper, we will consider the best practices for working with factor data. 

To do this, we will consider data from the General Social Survey. 


\section*{Loading the data}

We have several options for how to get this data. We could download it in SPSS or Stata formats and use the foreign package to read it in. The GSS download even provides an R file to do the translation for you. Here is the result of that:

<<>>=
source('../data/GSS.r')
str(GSS)
@


Obviously, this is less than ideal. Now, all the factor variables are encoded as integers, but their level labels have been lost. We have to look at a codebook to determine if \verb#SEX == 1# indicates male or female. We would rather preserve the integrated level labels. In order to do this, our best option is to download the data as an Excel file and use the \pkg{readxl} package to load it. 


<<warning=FALSE>>=
library(readxl)
GSS <- read_excel("../data/GSS.xls")
names(GSS) <- make.names(names(GSS), unique=TRUE)
str(GSS)
@

That's a little better. Now we have preserved the character strings. But, the data is not yet useable in an analysis. 

\section*{Renaming the variables}

One problem is that the variable names (while human readable) are full of spaces, so are hard to use. But, we can rename them.

There is a fragile way to do this in \pkg{base} \proglang{R}, but we'll use the more robust \verb#rename()# function from the \pkg{dplyr} package. \verb#rename()# 

<<>>=
library(dplyr)

GSS <- GSS %>% 
  rename(LaborStatus = Labor.force.status,
         PolParty = Political.party.affiliation,
         Age = Age.of.respondent)
@

<<>>=
sessionInfo()
@
\section*{Considering some factor variables}
Once we have variable names that are easier to work with, we can begin to think about how the data should be cleaned. 
<<>>=
GSS <- GSS %>%
  mutate(LaborStatus = factor(LaborStatus),
         PolParty = factor(PolParty))

levels(GSS$LaborStatus) # I wish I had a piece of dplyr code for this
levels(GSS$PolParty)
@


\section*{Task 1: Changing the labels of factors (base R)}

One action you might want to take is just to change the text of one (or more) of the factor labels, so it appears more nicely formatted in a \pkg{ggplot2} plot, for example.

Here is how I do that in base R. Typically, I end up ruining something in the process of doing this, so I *always* start with a summary call, to check after I have done my attempt. 

<<>>=
summary(GSS$LaborStatus)
with(GSS, summary(LaborStatus))   # I prefer this to the $
@

<<>>=
levels(GSS$LaborStatus) <- c(levels(GSS$LaborStatus)[1:5], 
                             "Temporarily not working", 
                             "Unemployed, laid off", 
                             "Working full time", 
                             "Working part time")
summary(GSS$LaborStatus)
@

This method is less than ideal, because it depends on the data coming in with the factor levels ordered in a particular way. If the data gets changed outside of R (perhaps with an additional level), this code will not perform as expected. (Additionally, if the code gets run more than once, it can also lead to unexpected behavior since the result is being added back into the original variable.)

\section*{Changing the labels of factors (dplyr)}

In the \pkg{dplyr} package, you can use the \verb#recode# function to do the same thing. There are a few things to remember with \verb#recode#. The first is that it is a vector function, which means it must be used within a \verb#mutate# call or with a variable pulled out using \verb#$#. The second is that you need to tell it which variable to recode, even if you are overwriting an existing variable. 

<<>>=
GSS <- GSS %>% 
  mutate(PolParty =  recode(PolParty, `Not str republican` = "Not a strong republican"))
@

\section*{Combining several levels into one}
This is another common task. Maybe you want fewer coefficients to interpret in your model, or the process that generated the data makes a finer distinction between categories than your research. For whatever the reason, you want to group together levels that are currently separate. 

How I do this in base R:
<<>>=
levels(GSS$LaborStatus) <- c("Not employed", "No answer",
                             "Other", "Not employed", 
                             "Not employed", "Not employed", 
                             "Not employed", "Employed", "Employed")
summary(GSS$LaborStatus)
@

\section{mosaic combining levels}

XX Is there any need to use mosaic now that case\_when is included in dplyr?

<<>>=
library(mosaic)
data(Births78)
Births78 <- Births78 %>%
  mutate(weekend = derivedFactor(weekend = wday== "Sun" | wday == "Sat", .default="weekday"))
@

\section*{Combining many categories into one}
In this data, age is provided as an integer for respondents 18-88, but then also includes the possible answer "89 or older" as well as a possible "No answer" and NA values. 
<<>>=
GSS <- GSS %>%
  mutate(Age = factor(Age))
summary(GSS$Age)
@

We might want to turn this into a factor variable with two levels: 18-65, and over 65. In this case, it would be much easier to deal with a conditional statement about the numeric values, rather than writing out each of the numbers as a character vector.  

But, in order to do that we need to make it numeric. 
<<>>=
# GSS$Age[GSS$Age == "No answer"] <- NA # Do I really need this? Nope!
levels(GSS$Age) <- c(levels(GSS$Age)[1:71], "89", "No answer")
GSS$Age <- as.numeric(as.character(GSS$Age))
summary(GSS$Age)
@

Of course, we're cheating a little bit here-- if we were going to use this as a numeric variable in an analysis, we wouldn't necessarily want to turn all the "89 or older" cases into the number "89". But, we're just on our way to a two-category factor, so those cases would have gone to the "65 and up" category one way or the other.

<<>>=
GSS <- GSS %>%
  mutate(Age = if_else(Age<65, "18-65", "65 and up"),
         Age = factor(Age))
summary(GSS$Age)
@

Another way to do this:

<<eval=FALSE>>=
# young <- as.character(18:64)
# derivedVariable(Age %in% young = "18-65", Age )
@

\section{Other examples}

Here's a placeholder for the other examples.

<<>>=
library(dplyr); library(mosaic); library(readr)
@

\subsection{Task 2: creating derived categorical variable}

XX THESE ARE STILL WORDED AS TASKS

The National Institutes of Alcohol Abuse and Alcoholism have published guidelines for moderate drinking.  These state that women, or men aged 65 or older should drink no more than one drink per day on average and no more than three drinks at a sitting.  

The {\tt HELPmiss} dataset from the \pkg{mosaicData} package includes baseline data from a randomized clinical trial (Health Evaluation and Linkage to Primary Care).  


\begin{tabular}{l|l}
variable&description \\ \hline 
sex&gender of subject {\tt female} or {\tt male} \\
i1&average number of drinks per day (in last 30 days) \\
i2&maximum number of drinks per day (in past 30 days) \\
age&age (in years) \\ \hline
\end{tabular}


Use these guidelines and the {\tt HELPsmall} dataset to create a new variable called {\tt abstinent} for those that reported no drinking based on the value of their {\tt i1} variable and {\tt moderate} for those that do not exceed the NIAAA guidelines.  All other non-missing values should be coded as {\tt highrisk}.

<<>>=
data(HELPmiss)
HELPsmall <- HELPmiss %>%
  mutate(i1 = ifelse(id==1, NA, i1)) %>%  # make one value missing
  select(sex, i1, i2, age)
@

<<>>=
glimpse(HELPsmall)

# I definitely want to remove these ASAP
#attach(HELPsmall)

HELPsmall <- with(HELPsmall,  # this won't work unless HELPsmall is made accessible
  mutate(HELPsmall,        
    drink_stat = case_when(
      i1 == 0 ~ "abstinent",
      i1 <= 1 & i2 <= 3 & sex=='female' ~ "moderate",
      i1 <= 1 & i2 <= 3 & sex=='male' & age >= 65 ~ "moderate",
      i1 <= 2 & i2 <= 4 & sex=='male' ~ "moderate",
      TRUE ~ "highrisk"
)))
tally( ~ drink_stat, data = HELPsmall)
@

\subsection{Task 3: Creating derived categorical variables}

XX move to appendix (since it duplicates the earlier example?)

Subjects in the HELP study were categorized into categories of drug and alcohol involvement, as displayed in the following table.

<<>>=
HELPbase <- HELPfull %>%
  filter(TIME==0)
tally( ~ PRIM_SUB + SECD_SUB, data=HELPbase)
@

Note that the following codings of substance use involvement were used:

\begin{tabular}{l|l}
value&description \\ \hline
0&None \\
1&Alcohol \\
2&Cocaine \\
3&Heroin \\
4&Barbituates \\
5&Benzos \\
6&Marijuana \\
7&Methadone \\
8&Opiates \\ \hline
\end{tabular}

Create a new variable called `primsub` that combines the primary and secondary substances into a categorical variable with values corresponding to primary and secondary substances of the form: {\tt alcohol only}, {\tt cocaine only}, `heroin only`, `alcohol-cocaine`, `cocaine-alcohol`, or `other`.  Code any group with fewer than 5 entries as `alcohol-other`, `cocaine-other`, or `heroin-other`.  If `PRIM\_SUB==6` make the `primsub` variable missing.

How many subjects are there in the `alcohol-none` group?  How many subjects are there in the `alcohol-other` group?  What are the three most common groups?

<<>>=
HELPbase <- with(HELPbase, 
  mutate(HELPbase, 
    primary= recode(PRIM_SUB, 
      `1`="alcohol",
      `2`="cocaine",
      `3`="heroin",
      `4`="barbituates",
      `5`="benzos",
      `6`="marijuana",
      `7`="methadone",
      `8`="opiates"),
    second=recode(SECD_SUB,
      `0`="none",
      `1`="alcohol",
      `2`="cocaine",
      `3`="heroin",
      `4`="barbituates",
      `5`="benzos",
      `6`="marijuana",
      `7`="methadone",
      `8`="opiates"),
    title=paste0(primary, "-", second) 
))
@
<<>>=
tally(~ primary, data=HELPbase)
tally(~ second, data=HELPbase)

counts <- HELPbase %>%
  group_by(primary, second) %>%
  summarise(observed=n())

merged <- left_join(HELPbase, counts, by=c("primary", "second"))
@

<<>>=
merged <- with(merged, 
  mutate(merged,
    title = 
      case_when(
        observed < 5 & primary=="alcohol" ~ "alcohol-other",
        observed < 5 & primary=="cocaine" ~ "cocaine-other",
        observed < 5 & primary=="heroin" ~ "heroin-other",
        TRUE ~ title),
    title = ifelse(primary=="marijuana", NA, title)))
tally(~ title + observed, data=merged)
@

Answers:

<<>>=
tally(~ title=="alcohol-none", data=merged)
tally(~ title=="alcohol-other", data=merged)
sort(tally(~ title, data=merged), decreasing=TRUE)[1:3]
@

\section*{Acknowledgements}

Thanks to my students Kelcie Grenier, Kat Kyuchukov, and Emily Ruppel, whose spring 2016 project in my SDS 291 class formed the inspiration for this paper. 




\section*{Ideas}
Two ways to do each thing (as long as one isn't totally stupid)
Why is this hard?
Why is this error-prone?
Missing values
Appendices for less interesting examples?


\bibliography{bibliography.bib}

\end{document}
