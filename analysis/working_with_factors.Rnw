\documentclass[fleqn,10pt,lineno]{wlpeerj}

\usepackage{url}

\let\proglang=\textsf
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}
\def\newblock{\hskip .11em plus .33em minus .07em}


\title{Wrangling categorical data in R}

\author[1]{Amelia McNamara}
\author[2]{Nicholas J Horton}
\affil[1]{Statistical and Data Sciences Program, Smith College}
\affil[2]{Department of Mathematics and Statistics, Amherst College}


\keywords{statistical computing; data derivation; data science; data management}

\begin{abstract}
Data wrangling is a critical foundation of data science, and wrangling of categorical data is an important component of this process. However, categorical data can introduce unique issues in data wrangling, particularly in real-world settings with collaborators and periodically-updated dynamic data. This paper discusses common problems arising from categorical variable transformations in R, demonstrate the use of factors, and suggest approaches to address data wrangling challenges. For each problem, we present at least two strategies for management, one in base R and the other from the `tidyverse.' We consider several motivating examples, suggest defensive coding strategies, and outline principles for data wrangling to help ensure data quality and sound analysis.
\end{abstract}

\begin{document}

<<setup, include=FALSE>>=
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, 
                      size='footnotesize', cache=FALSE, error=TRUE, tidy=FALSE)
@

\flushbottom
\maketitle
\thispagestyle{empty}

\section*{Introduction}

Wrangling skills provide an intellectual and practical foundation for data science. Careless data derivation operations can lead to errors or inconsistencies in analysis~\citep{HerMur2015, FitzPen2014}. The wrangling of categorical data presents particular challenges and is highly relevant because many variables are categorical (e.g., gender, income bracket, U.S. state) but coded with numerical values. It is easy to break the relationship between category numbers and category labels without realizing it, thus losing the information encoded in a variable. If data sources change upstream (for example, if a domain expert is providing spreadsheet data at regular intervals), code that worked on the initial data may not generate an error message, but could silently produce incorrect results.  

Statistical and data science tools need to foster good practice and provide a robust environment for data wrangling and data management.  This paper focuses on how \proglang{R} deals with categorical data, and showcases best practices for categorical data manipulation in \proglang{R} to produce reproducible workflows. We consider a number of common idioms related to categorical data that arise frequently in data cleaning and preparation, propose some guidelines for defensive coding, and discuss settings where analysts often get tripped up when working with categorical data. 

For example, data ingested into \proglang{R} from spreadsheets can lead to problems with categorical data because of the different storage methods possible in both \proglang{R} and the spreadsheets themselves~\citep{WilBry2016}. The examples below will help flag when these issues arise or avoid them altogether. 

To ground our work, we will compare and contrast how categorical data are treated in \pkg{base} \proglang{R} versus the tidyverse~\citep{Wic2014, Wic2016b}. Tools from the tidyverse, discussed in another paper in this special issue (see https://github.com/dsscollection/tidyflow), are designed to make analysis purer, more predictable, and pipeable. Key components of the tidyverse that we will address in this paper include \pkg{ggplot2}, \pkg{dplyr}, \pkg{tidyr}, \pkg{forcats}, and \pkg{readr}. This suite of packages help facilitate a reproducible workflow where a new version of the data could be supplied in the code with updated results produced~\citep{Bro2015}. While \proglang{R} code written in \pkg{base} can also have this quality, a common tendency is to use row or column numbers in code, which makes the result less reproducible. Wrangling of categorical data can make this task even more complex (e.g., if a new level of a categorical variable is added in an updated dataset or inadvertently introduced by a careless error in a spreadsheet to be ingested into \proglang{R}).  

Our goal is to make the case that it is better to work with categorical data using tidyverse packages than with \pkg{base} \proglang{R}. Tidyverse code is more human readable, which can help reduce errors from the start, and the functions we highlight have been designed to make it harder to accidentally remove relationships implicit in categorical data. Because these issues are even more salient for new users, we recommend that instructors should teach tidyverse approaches from the start. 


\section*{Categorical data in R: factors and strings}
Consider a variable describing gender including categories \verb#male#, \verb#female# and \verb#non-conforming#. In \proglang{R}, there are two ways to store this information. One is to use a series of \emph{character strings}, and the other is to store it as a \emph{factor}. 

In early versions of \proglang{R}, storing categorical data as a factor variable was considerably more efficient than storing the same data as strings, because factor variables only store the factor labels once~\citep{Pen2015, Lum2015}. However, \proglang{R} uses a global string pool, so each unique string is only stored once, so the storage is now less of an issue~\citep{Pen2015}. For historical (or possibly anachronistic) reasons, many functions store variables by default as factors.

While factors are important when including categorical variables in regression models, they
can be tricky to deal with, since many operations applied to them return different values than when applied to character vectors.  As an example, consider a set of decades,

<<>>=
x1 <- c(10, 10, 20, 20, 40)
x1f <- factor(x1)
ds <- data.frame(x1, x1f)
library(dplyr)
ds <- ds %>%
  mutate(x1recover = as.numeric(x1f))
ds
@

Instead of creating a new variable with a numeric version of the value of the factor variable \verb#x1f#, the variable is created with a factor number (i.e., 10 is mapped to 1, 20 is mapped to 2, and 40 is mapped to 3). This result is unexpected because \verb#base::as.numeric()# is intended to recover numeric information by coercing a character variable. Compare the following:

<<>>=
as.numeric(c("hello"))
as.numeric(factor(c("hello")))
@

The unfortunate behavior of factors in \proglang{R} has led to an online movement against the default behavior of many data import functions to make factors out of any variable composed as strings \citep{Pen2015}. The tidyverse is part of this movement, with functions from the \pkg{readr} package defaulting to leaving strings as-is. (Others have chosen to add \verb#options(stringAsFactors=FALSE)# into their startup commands.)

Although the storage issues have been solved, and there are problems with defaulting strings to factors, factors are still necessary for some data analytic tasks. The most salient case is in modeling. When you pass a factor variable into \verb#lm()# or \verb#glm()#, \proglang{R} automatically creates indicator (or more colloquially `dummy') variables for each of the levels and picks one as a reference group. 

For simple cases, this behavior can also be achieved with a character vector. However, to choose which level to use as a reference level or to order classes, factors must be used. For example, if a factor encodes income levels as \verb#low, medium, high#, it might make sense to use the lowest income level (\verb#low#) as the reference class so that all the other coefficients can be interpreted in comparison to it. However, \proglang{R} would use \verb#high# as the reference by default because `h' comes before `l' in the alphabet. 

While ordering is particularly important when doing ordinal logistic regression and multinomial logistic regression, the use of alphabetic ordering by default means even simple linear regression can be affected. 


While factors are important, they can often be hard to deal with. Because of the way the group numbers are stored separately from the factor labels, it can be easy to overwrite data in such a way that the original data are lost. They present a steep learning curve for new users.  In this paper, we will suggest best practices for working with factor data. 

To motivate this process, we will consider data from the General Social Survey~\citep{GSS2016}. The General Social Survey is a product of the National Data Program for the Social Sciences, and the survey has been conducted since 1972 by NORC at the University of Chicago. It contains data on many factors of social life, and is widely used by social scientists. (In this paper we consider data from 2014.)

There are some import issues inherent to the data which are not particular to categorical data (see Appendix A for details). We'll work with the data with slightly cleaned up variable names.

<<>>=
library(dplyr)
GSS <- read.csv("../data/GSSoriginal.csv")
glimpse(GSS)
@

The remainder of this paper is organized around case studies (examples) to carry out four specific and useful tasks:
\begin{enumerate}
\item Changing the labels of factor levels,
\item Reordering factor levels,
\item Combining several levels into one (both string-like labels and numeric, probably go together), and
\item Making derived factor variables.
\end{enumerate}

Each case study begins with a problem, and presents several solutions. Typically, we contrast a method that uses the functionality of \pkg{base} \proglang{R} functions with an approach from the tidyverse along with some annotations of the code as needed. We will argue that while both approaches can solve the problem, the tidyverse solution tends to be simpler, easier to learn, and more robust. 

\section*{Changing the labels of factor levels}
In our first example, we will be considering the labor status variable. It is a categorical variable with \Sexpr{length(levels(GSS$Labor.force.status))} levels. Most of the labels are spelled out fully, but a few are strangely formatted. We want to change this. 

This is a specific case of the more general problem of changing the text of factor labels, so they appear more nicely formatted in a plot, for example.

There are two typical approaches in \pkg{base} \proglang{R}. One is more compact, but depends on the levels of the factor not changing in the data being fed in, and the other is more robust, but extremely verbose. In contrast, the \pkg{dplyr} package offers a more human readable method, while also supporting reproducibility. 


\subsection*{Compact but fragile (base R)}
<<>>=
levels(GSS$Labor.force.status)
summary(GSS$Labor.force.status)
@

<<>>=
levels(GSS$Labor.force.status) <- c(levels(GSS$Labor.force.status)[1:5], 
                             "Temporarily not working", 
                             "Unemployed, laid off", 
                             "Working full time", 
                             "Working part time")
summary(GSS$Labor.force.status)
@

This method is less than ideal, because it depends on the data coming in with the factor levels ordered in a particular way. We call this a \emph{fragile} process since future datasets may cause a workflow to break (a related concept in computer science is \emph{software brittleness}).  Why is this fragile?  By default, \proglang{R} orders factor levels alphabetically. So, ``Keeping house'' is first not because it is the most common response, but simply because `k' comes first in the alphabet. If the data gets changed outside of R, for example so responses currently labeled ``Working full time'' get labeled ``Full time work'', the code will not generate an error message, but will mislabel all the data such that the \verb#Labor.force.status# variable is essentially meaningless.  (Another possible issue arises with strings that include non-ASCII characters, where the default of order levels may vary from locale to locale.)

The workflow will also fail if additional factor levels are added after the fact. In our experience, both with students and scientific collaborators, spreadsheet data can be easily changed in these ways. Others have noted this concern~\citep{Lee2016}. 

On a similar note, 
the following code silently makes a missing value.
<<>>=
factor("a", levels="c")
@


\subsection*{Robust but verbose (base R)}
Another (more robust method) to recode this variable in \pkg{base} \proglang{R} is to use subsetting to overwrite particular values in the data. 

<<>>=
summary(GSS$Labor.force.status)
GSS$Labor.force.status <- as.character(GSS$Labor.force.status)
GSS$Labor.force.status[GSS$Labor.force.status=="Working full time"] <- 
  "Full time"
GSS$Labor.force.status[GSS$Labor.force.status=="Working part time"] <- 
  "Part time"
GSS$Labor.force.status[GSS$Labor.force.status=="Unemployed, laid off"] <- 
  "Unemployed"
GSS$Labor.force.status <- factor(GSS$Labor.force.status)
summary(GSS$NewParty)
@

This second approach is more robust, because if the labels or ordering of levels changes before this code is run it will not overwrite labels on the incorrect data. However, this approach has a number of limitations in addition to being tedious and error prone. It is possible to miss cases, and misspelling and cut-and-paste errors can mean pieces of the code do not actually do anything. 


\subsection*{Direct and robust (dplyr)}

The \verb#recode()# function in the \pkg{dplyr} package is a vectorized function, which combines the robustness of the second base R approach while also reducing the verbosity. It still suffers from the problem of misspelling and cut-and-paste errors, because it will not generate an error message if you try to recode a non-existent level. 
<<>>=
GSS <- GSS %>% 
  mutate(Labor.force.status =  
    recode(Labor.force.status, 
           `Temporarily not working  ` = "Not working",
           `Keeping house` = "Homemaker",
           `School` = "In school",
           `Part time` = "Working part time",
           `Full time` = "Working full time"))
summary(GSS$Labor.force.status)
@
In the above example, notice the trailing space in \verb#`Temporarily not working `# in the \verb#recode()# call. Because of this typo (the original factor level is actually \verb#`Temporarily not working'#), the original factor level persists after the recode. 

\subsection*{Aside -- Editing whitespace out of levels}

Whitespace can be dealt with when data is read, or later using string manipulations. This can be done using the \verb#trimws()# function  in \pkg{base} \proglang{R}. 
<<>>=
gender <- factor(c("male ", "male  ", "male    ", "male"))
levels(gender)
gender <- factor(trimws(gender))
levels(gender)
@


\section*{Reordering factor levels}
Often, factor levels have a natural ordering to them. However, the default in \pkg{base} \proglang{R} is to order levels alphabetically. So, users must have a way to impose order on their factor variables. 

Again, there is a fragile way to reorder the factor levels in base R, and a more robust method in the tidyverse. 

\subsection*{Fragile method (base R)}

One common way to make this sort of change is to pass an argument to \verb#levels# within the \verb#factor()# function. However, this is fragile with respect to spelling issues and trailing whitespace. 

<<>>=
test <- GSS$Opinion.of.family.income
summary(test)
test <- factor(test, levels = c("Far above average", "Above average", "Average ", "Below Average", "Far below average", "Don't know", "No answer"))
summary(test)
@

Note that many of the category totals come through appropriately, but several totals get set to 0 (`Average' because of the trailing whitespace and `Below Average' because of the mistaken capitalization). These errors can be exceedingly frustrating to troubleshoot. 

An approach that looks similar upon inspection but actually performs quite differently is to overwrite the \verb#levels()# of the factor outside the \verb#factor()# command. It is tempting for new analysts to write code such as the following, which completely breaks the association between rows and factor labels the data set.
<<>>=
test <- GSS$Opinion.of.family.income
summary(test)
levels(test) <- c("Far above average", "Above average", "Average", "Below Average", 
  "Far below average", "Don't know", "No answer")
summary(test)
@

An approach that will not suffer from spelling mistakes is to use numeric indexing the reorder the levels. 

<<>>=
summary(GSS$Opinion.of.family.income)
levels(GSS$Opinion.of.family.income)
levels(GSS$Opinion.of.family.income) <- 
  levels(GSS$Opinion.of.family.income)[c(5,1:3,6,4,7)]
levels(GSS$Opinion.of.family.income)
@

This is both verbose and depends on the number and order of the levels staying the same. If another factor level is added to the dataset, the above code will generate an error message because the number of levels differs. This example illustrates why it is sometimes dangerous to replace an old version of a data frame with a new version.

Even worse, if the code gets run more than once, the order will be broken. Particularly when working interactively, this is all too easy to do. 

<<>>=
levels(GSS$Opinion.of.family.income) <- 
  levels(GSS$Opinion.of.family.income)[c(5,1:3,6,4,7)]
levels(GSS$Opinion.of.family.income)
@

The more times the code is run, the more mixed up the labels and observations get. 

\subsection*{Robust method}
Because of the fragility and potential for frustration and mistakes associated with reordering levels in base R, we recommend the use of a tidyverse package. The package \pkg{forcats} (where the name is an anagram of the word factors!)~\citep{Wic2016}. \pkg{forcats} is included in the tidyverse.  It includes a \verb#fct_relevel()# function that does exactly what we want. It allows us to specify the order of our factor levels (either completely or partially) and is robust to re-running code in an interactive session. 
<<>>=
# devtools::install_github("hadley/forcats")
library(forcats)
summary(GSS$Opinion.of.family.income)
GSS <- GSS %>%
  mutate(Opinion.of.family.income = 
           fct_relevel(Opinion.of.family.income, 
                       "Far above average", 
                       "Above average", 
                       "Average", 
                       "Below average", 
                       "Far below average"))
summary(GSS$Opinion.of.family.income)
@

Notice the levels we did not mention end up at the back end of the ordering. Running the code again does not break things. 

<<>>=
GSS <- GSS %>%
  mutate(Opinion.of.family.income = 
           fct_relevel(Opinion.of.family.income, 
                       "Far above average", 
                       "Above average", 
                       "Average", 
                       "Below average", 
                       "Far below average"))
summary(GSS$Opinion.of.family.income)
@

\section*{Combining several levels into one}

\subsection*{Combining discrete levels}
This is another common task. Maybe you want fewer coefficients in your model, or the data-generating process makes a finer distinction between categories than your research. For whatever the reason, you want to group together levels that are currently separate. 

\subsubsection*{Fragile method (base R)}
This method overwrites the labels of factor levels with repeated labels in order to group levels together. 
<<>>=
levels(GSS$Labor.force.status) <- c("Not employed", "No answer",
                             "Other", "Not employed", 
                             "Not employed", "Not employed", 
                             "Not employed", "Employed", "Employed")
summary(GSS$Labor.force.status)
@
As before, this is fragile because it depends on the order of the factor levels not changing, and on a human accurately counting the indices of all the levels they wish to change. 

\subsubsection*{Robust method}
The \verb#recode()# does what we want. 
<<>>=
levels(GSS$Race.of.respondent)
GSS <- GSS %>% 
  mutate(Race.of.respondent = recode(Race.of.respondent, 
    `Black` = "Nonwhite", 
    `Other` = "Nonwhite"))
levels(GSS$Race.of.respondent)
@


\subsection*{Combining numeric-type levels}
Combining numeric-type levels is a frequently-occurring problem even when \verb#stringsAsFactors = FALSE#. Often variables like age or income are right-censored, so there is a final category that lumps the remainder of people into one group. This means the data is necessarily at least a character string if not a factor. However, it may be more natural to work with numeric expressions when recoding this data. 

In this data, age is provided as an integer for respondents 18-88, but also includes the possible answer ``89 or older'' as well as a possible ``No answer'' and NA values. 

We might want to turn this into a factor variable with two levels: 18-65, and over 65. In this case, it would be easier to deal with a conditional statement about the numeric values, rather than writing out each of the numbers as a character vector.  

\subsubsection*{Fragile method (base R)}
In order to break this data apart as simply as possible, we need to make it numeric. To start, we recode the label for ``89 or older" to read ``89". Already, we are doing something fragile. 
<<>>=
GSS$BaseAge <- GSS$Age.of.respondent
levels(GSS$BaseAge)
levels(GSS$BaseAge) <- c(levels(GSS$BaseAge)[1:71], "89", "No answer")
@
When we look at the levels, we can see the first 71 levels correspond to the ages 18-88, and are in the order we would expect, so we are leaving those as-is. Then we are overwriting the data where \verb#BaseAge == "89 or older"# with simply \verb#89#. Finally, we can convert the factor to a character vector and then to a numeric one.

<<>>=
GSS$BaseAge <- as.numeric(as.character(GSS$BaseAge))
summary(GSS$BaseAge)
@

We're avoiding the pitfall from the introduction here by not simply using \verb#as.numeric()# on the factor variables (this would convert 18 to 1, 19 to 2, etc.). And of course, we're cheating a little bit here-- if we were going to use this as a numeric variable in an analysis, we wouldn't necessarily want to turn all the ``89 or older" cases into the number ``89". But, we're on our way to a two level factor, so those cases would have gone to the ``65 and up" category one way or the other.

Now, we can write some conditional logic
<<>>=
summary(GSS$BaseAge)
GSS$BaseAge <- ifelse(GSS$BaseAge > 65, "18-64", "65 and up")
GSS$BaseAge <- factor(GSS$BaseAge)
summary(GSS$BaseAge)
@

\subsubsection*{Robust method}
The \pkg{dplyr} method follows similar logic. However, instead of explicitly overwriting \verb#89 or older# with the number 89, we use the \pkg{readr} \verb#parse_number()# function to remove the numbers from the factor labels. This works for the labels that already look numeric, like \verb#"18.000000"# as well as for \verb#"89 or older"#. Then, we can include the conditional logic for splitting the variable within a mutate command. 
<<>>=
library(readr)
GSS <- GSS %>%
  mutate(dplyrAge = parse_number(Age.of.respondent)) %>%
  mutate(dplyrAge = if_else(dplyrAge < 65, "18-65", "65 and up"),
         dplyrAge = factor(dplyrAge))
summary(GSS$dplyrAge)
@

Note that you need to be very sure that the strings with a number have a relevant number. You could accidentally add a number that is not meaningful if numbers appear in unanticipated ways. 

\section*{Creating derived categorical variables}
Challenges often arise when data scientists need to create derived categorical variables.  As an example, consider an indicator of moderate drinking status. The National Institutes of Alcohol Abuse and Alcoholism have published guidelines for moderate drinking \cite{rethinkdrink}. 
These guidelines state that women (or men aged 65 or older) should drink no more than one drink per day on average and no more than three drinks on any single day or at a sitting.
Men under age 65 should drink no more than two drinks per day on average and no more than four drinks on any single day.
The {\tt HELPmiss} dataset from the \pkg{mosaicData} package includes baseline data from a randomized clinical trial (Health Evaluation and Linkage to Primary Care) \cite{same:lars:hort:2003}.  These subjects were recruited from a detoxification center, hence those that reported alcohol as their primary substance of abuse have extremely high rates of drinking.


\begin{tabular}{l|l}
variable&description \\ \hline 
sex&gender of subject {\tt female} or {\tt male} \\
i1&average number of drinks per day (in last 30 days) \\
i2&maximum number of drinks per day (in past 30 days) \\
age&age (in years) \\ \hline
\end{tabular}


These guidelines can be used to create a new variable called {\tt abstinent} for those reporting no drinking based on the value of their {\tt i1} variable and {\tt moderate} for those that do not exceed the NIAAA guidelines, with all other non-missing values coded as {\tt highrisk}.

<<>>=
library(dplyr)
library(mosaic)
library(readr)
@

Because missing values can become especially problematic in more complex derivations, we will make one value missing so we can ensure our data wrangling accounts for the missing value.
<<>>=
data(HELPmiss)
HELPsmall <- HELPmiss %>%
  mutate(i1 = ifelse(id==1, NA, i1)) %>%  # make one value missing
  select(sex, i1, i2, age)
head(HELPsmall, 2)
@

\subsection*{Fragile method (base R)}

<<>>=
# create empty repository for new variable
drinkstat <- character(length(HELPsmall$i1))
# create abstinent group
drinkstat[HELPsmall$i1==0] <- "abstinent"
# create moderate group
drinkstat[(HELPsmall$i1>0 & HELPsmall$i1<=1 & 
   HELPsmall$i2<=3 & HELPsmall$sex=="female") |
  (HELPsmall$i1>0 & HELPsmall$i1<=2 & 
   HELPsmall$i2<=4 & HELPsmall$sex=="male")] = "moderate"
# create highrisk group
drinkstat[((HELPsmall$i1>1 | HELPsmall$i2>3) & HELPsmall$sex=="female") |
  ((HELPsmall$i1>2 | HELPsmall$i2>4) & HELPsmall$sex=="male")] = "highrisk"
# account for missing values
is.na(drinkstat) <- is.na(HELPsmall$i1) | is.na(HELPsmall$i2) | 
  is.na(HELPsmall$sex)
drinkstat <- factor(drinkstat)
table(drinkstat, useNA = "always")
@

While this approach works, it is hard to follow and to check or debug. The logical conditions are all correctly coded, but require many repetitions of \verb#HELPsmall$variable#, and the missing value was not handled by default (without the \verb#is.na()# call, the missing value would default to be \verb#"highrisk"# because of their extreme value for \verb#i2#). 


\subsection*{Robust method (dplyr)}
<<>>=
HELPsmall <- with(HELPsmall,  # this won't work with current dplyr
  # unless HELPsmall is made accessible to mutate() through with()
  # Hadley was aware of this issue with case_when(), though the issue is closed at
  # https://github.com/hadley/dplyr/issues/1996
  mutate(HELPsmall,        
    drink_stat = case_when(
      i1 == 0 ~ "abstinent",
      i1 <= 1 & i2 <= 3 & sex=='female' ~ "moderate",
      i1 <= 1 & i2 <= 3 & sex=='male' & age >= 65 ~ "moderate",
      i1 <= 2 & i2 <= 4 & sex=='male' ~ "moderate",
      is.na(i1) ~ "missing",  # this can't be NA
      TRUE ~ "highrisk"
)))
tally( ~ drink_stat, exclude=NULL, data = HELPsmall)
@

In the robust tidyverse method, the same logic is used, but the conditions are clearer and more comprehensible.  Instead of one complex Boolean condition for \verb#moderate#, three separate lines can be used to match the different options. While the end result is the same, this code is more human readable and it is harder to miss possible edge cases. 


\section*{Defensive coding}

It is always good practice to code in a defensive manner. Investing a little time up front can help avoid painful errors later. For the setting we are considering, defensive coding might involve adding conditional testing statements into code creating or modifying factors. These testing statements can help ensure the data have not changed from one session to another, or as the result of changes to the raw data. 

As an example, we might want to check there are exactly three levels for
the drinking status variable in the HELP dataset. If there were fewer or more than three levels, something would have gone wrong with our code. We can use the \pkg{assertthat} package to help with this. 
<<>>=
library(assertthat)
levels(drinkstat)
assert_that(length(levels(drinkstat))==3)
@

We also might want to ensure the factor labels are exactly what we were expecting. Perhaps we want to make sure our Race variable has been collapsed into two categories, with particular levels. We can use \verb#expect_equivalent()# and \verb#expect_equal()# from the \pkg{testthat} package to make this check. 

<<error = TRUE>>=
library(testthat)
str(levels(GSS$Race.of.respondent))
str(c("White", "Nonwhite"))
str(sort(c("White", "Nonwhite")))
#expect_equivalent(levels(GSS$Race.of.respondent), 
  # c("White", "Nonwhite")) # This doesn't work, but we wish it did.
expect_equivalent(levels(GSS$Race.of.respondent), c("Nonwhite", "White")) 
expect_equal(levels(GSS$Race.of.respondent), c("Nonwhite", "White")) 
expect_equivalent(levels(GSS$Race.of.respondent), sort(c("Nonwhite", "White"))) 
@

\section*{Conclusion}

Categorical variables arise commonly in most datasets.  Aspects of data wrangling involving categorical variables can be problematic and error-prone.  In this paper we have outlined some example case studies where analytic tasks can be simplified and made more robust through use of new tools available in the tidyverse. We believe further work is needed to continue to make it easier to undertake analyses requiring data wrangling (particularly with respect to categorical data). New tools and an increased emphasis on defensive coding may help improve the quality of data science moving forward.

\section*{Acknowledgements}

Thanks to Hadley Wickham, Colin Rundel, and Zev Ross for helpful comments and suggestions on 
an earlier draft.


\appendix

\section*{Appendix A: Loading the data}\label{load}
Since this is a reproducible special issue, we want to make sure our data ingestation process is as reproducible as possible. We are using the General Social Survey (GSS) data, which includes many years of data (1972-2014) and many possible variables (150-800 variables, depending on the year)~\citep{GSS2016}. However, the GSS data has some idiosyncrasies. So, we are attempting good-enough practices for data ingest~\citep{WilBry2016}.

The major issue related to reproducibility is the fact that the dataset is not available through an API. For SPSS and Stata users, yearly data are available for direct download on the website. For more format possibilities, users must go through an online wizard to select variables and years for the data they wish to download~\citep{GSS2016b}. For this paper, we selected a subset of the demographic variables and the year 2014. The possible output options from the wizard are Excel (either data and metadata or metadata only), SPSS, SAS, Stata, DDI, or R script. We selected both the Excel and R formats to look at the differences. 

The R format provided by the GSS is actually a Stata file and custom R script  using the \pkg{foreign} package to do the translation for you. Here is the result of that process.

<<>>=
source('../data/GSS.r')
glimpse(GSS)
@

Obviously, the result is less than ideal. All of the factor variables are encoded as integers, but their level labels have been lost. We have to look at a codebook to determine if \verb#SEX == 1# indicates male or female. We would rather preserve the integrated level labels. In order to do this, our best option is to use the Excel file and use the \pkg{readxl} package to load it. 


<<warning=FALSE>>=
library(readxl)
GSS <- read_excel("../data/GSS.xls")
glimpse(GSS)
@

This is a little better. Now we have preserved the character strings. But, the data is not yet usable in an analysis. One problem is some of the variable names include spaces, so they are hard to use. Also, one variable name is repeated, perhaps because of an error in the data wizard. To fix these issues, we need to rename the variables so all variables have unique names without spaces. 

<<warning=FALSE>>=
names(GSS) <- make.names(names(GSS), unique=TRUE)
names(GSS)
@

These names are an improvement, but now some are full of periods. We'd like to rename the most extreme cases to make the names more human readable. As with all the tasks in this paper, there is a fragile way to do this in \pkg{base} \proglang{R}, but we'll use the more robust \verb#rename()# function from the \pkg{dplyr} package. \verb#rename()# 

<<>>=
library(dplyr)
GSS <- GSS %>% 
  rename(Year = Gss.year.for.this.respondent.......................,
         Occupational.prestige.score.1970 = Rs.occupational.prestige.score...1970.)
names(GSS)
@
With the data loaded and the names adjusted, we can write the data to a new file for use in the body of the paper. 
<<>>=
library(readr)
write_csv(GSS, path="../data/GSScleaned.csv")
@
A version of this file is used as our motivating example.

\section*{Appendix B: Closing exercise}
We have included the following as a possible supplementary exercise.

Subjects in the HELP study were also categorized into categories of primary and secondary drug and alcohol involvement, as displayed in the following table.

<<>>=
HELPbase <- HELPfull %>%
  filter(TIME==0)
tally( ~ PRIM_SUB + SECD_SUB, data=HELPbase)
@

The following coding of substance use involvement was used in the study.

\begin{tabular}{l|l}
value&description \\ \hline
0&None \\
1&Alcohol \\
2&Cocaine \\
3&Heroin \\
4&Barbituates \\
5&Benzos \\
6&Marijuana \\
7&Methadone \\
8&Opiates \\ \hline
\end{tabular}

Create a new variable called \verb#primsub# combining the primary and secondary substances into a categorical variable with values corresponding to primary and secondary substances of the form: {\tt alcohol only}, {\tt cocaine only}, `heroin only', `alcohol-cocaine', `cocaine-alcohol', or `other'.  Code any group with fewer than 5 entries as `alcohol-other', `cocaine-other', or `heroin-other'.  If \verb#PRIM\_SUB==6# make the \verb#primsub# variable missing.

How many subjects are there in the `alcohol-none' group?  How many subjects are there in the `alcohol-other' group?  What are the three most common groups?

SOLUTION:
<<>>=
HELPbase <- with(HELPbase, 
  mutate(HELPbase, 
    primary= recode(PRIM_SUB, 
      `1`="alcohol",
      `2`="cocaine",
      `3`="heroin",
      `4`="barbituates",
      `5`="benzos",
      `6`="marijuana",
      `7`="methadone",
      `8`="opiates"),
    second=recode(SECD_SUB,
      `0`="none",
      `1`="alcohol",
      `2`="cocaine",
      `3`="heroin",
      `4`="barbituates",
      `5`="benzos",
      `6`="marijuana",
      `7`="methadone",
      `8`="opiates"),
    title=paste0(primary, "-", second) 
))
@
<<>>=
tally(~ primary, data=HELPbase)
tally(~ second, data=HELPbase)

counts <- HELPbase %>%
  group_by(primary, second) %>%
  summarise(observed=n())

merged <- left_join(HELPbase, counts, by=c("primary", "second"))
@

<<>>=
merged <- with(merged, 
  mutate(merged,
    title = 
      case_when(
        observed < 5 & primary=="alcohol" ~ "alcohol-other",
        observed < 5 & primary=="cocaine" ~ "cocaine-other",
        observed < 5 & primary=="heroin" ~ "heroin-other",
        TRUE ~ title),
    title = ifelse(primary=="marijuana", NA, title)))
tally(~ title + observed, data=merged)
@

<<>>=
tally(~ title=="alcohol-none", data=merged)
tally(~ title=="alcohol-other", data=merged)
sort(tally(~ title, data=merged), decreasing=TRUE)[1:3]
@

\bibliography{bibliography.bib}

\end{document}
